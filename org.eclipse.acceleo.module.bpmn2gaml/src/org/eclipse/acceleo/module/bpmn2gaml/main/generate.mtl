[comment encoding = UTF-8 /]
[module generate('http://www.cpoubel.org/simplifiedbpmn')]


[template public generateElement(aResource : ResourceRole) post (trim())]
[comment @main/]
[file (aResource.name + '.gaml', false, 'Cp1252')]
model [aResource.name.normaliseString()/]

/**
* This model is the result of a transformation from a BPMN representation of a ResourceRole to a GAML species skeleton
* It has been automatically generated from a specification, and may not be exactly suited to your modeling needs. Feel free
* to adapt and modify this file as needed.
*/

species [aResource.name.normaliseString()/] {

	[comment This generates a counter for every process and task
	It is intended to be used for validation of the simulation and/or the diagrams /]
	[for (process : FlowElementContainer | aResource.processes)]
	int counter_[process.name.normaliseString()/] <- 0;
		[for (task : Task | getTasks(process))]
	int counter_[task.name.normaliseString()/] <- 0;
		[/for]
	[/for]

	/**
	* This is a list of methods derived from the different tasks specified in this agent's BPMN representation
	* They are supposed to be called at each cycle when the agent is doing the corresponding activity
	* Each action returns a boolean indicating if the corresponding task is over
	*/

	[comment This generates an action for each task there is in the BPMN diagram(s) /]
	[for (process : FlowElementContainer | aResource.processes)]
		[for (task : Task | getTasks(process))]
	bool ['action_' + task.name.normaliseString()/] {
		//TODO
		return false;
	}
		[/for]
	[/for]

	//This string is used to determine which process the agent is currently doing
	string current_process <- nil;

	//This list is used to keep track of which task(s) the agent is currently doing
	list<string> tasks <- ['['/][']'/];

	reflex idle when: (current_process = nil) {
	/**
	* This is where the agent will look at its environment and decide which process to use
	* For each process, replace "true" by the corresponding condition
	*/
	[for (process : FlowElementContainer | aResource.processes)]
		[let start : StartEvent = process.getStartEvent()]
		if (true and current_process = nil) {
			current_process <- "[process.name.normaliseString()/]";
			[start.generateTasks()/]
		}
		[/let]
	[/for]
	}

	[comment For each process, a reflex is generated, respecting tasks' order/]
	[for (process : FlowElementContainer | aResource.processes)]
	reflex [process.name.normaliseString()/] when: (current_process = "[process.name.normaliseString()/]") {
		counter_[process.name.normaliseString()/] <- counter_[process.name.normaliseString()/] + 1;
		[for (element : FlowNode | process.flowElements->select(e | e.oclIsKindOf(FlowNode) and not e.oclIsKindOf(Event)))]
		[element.generateTasks()/]
		[/for]
	}
	[/for]

}
[/file]
[/template]
[comment Returns the list of tasks of a process /]
[query public getTasks(p : FlowElementContainer) : Set(Task) =
	p.flowElements->select(e | e.oclIsTypeOf(Task))
/]

[query public getStartEvent(p : FlowElementContainer) : StartEvent =
	p.flowElements->any(oclIsTypeOf(StartEvent))
/]

[query public getGateways(p : FlowElementContainer) : Set(Gateway) =
	p.flowElements->select(e | e.oclIsKindOf(Gateway))
/]


[template public normaliseString(s : String)]
[s.toLower().substituteAll(' ', '_').substituteAll('\'', '_')/]
[/template]


[comment These templates are used to generate the reflexes from tasks, events and gateways /]
[template public generateTasks(f : FlowNode)]
//TODO define template for type [f.eClass().name/]
[/template]

[template public generateTasks(f : StartEvent) post(trim())]
[for (flow : SequenceFlow | f.outgoing)]
	[let nextNode : FlowNode = flow.targetRef]
		[if (nextNode.oclIsTypeOf(Task))]
if(not ("[nextNode.name.normaliseString()/]" in tasks)) {
	add "[nextNode.name.normaliseString()/]" to: tasks;
}
		[elseif (nextNode.oclIsKindOf(Gateway))]
			[if (nextNode.oclAsType(Gateway).gatewayDirection = GatewayDirection::Diverging)]
[generateDivergingConditions(nextNode)/]
			[elseif (nextNode.oclAsType(Gateway).gatewayDirection = GatewayDirection::Converging)]
if(not ("[getConvergingReflexName(nextNode.oclAsType(Gateway))/]" in tasks)) {
	add "[getConvergingReflexName(nextNode.oclAsType(Gateway))/]" to: tasks;
}
			[/if]
		[/if]
	[/let]
[/for]
[/template]

[template public generateTasks(f : Task) post(trim())]
if ("[f.name.normaliseString()/]" in tasks) {
	bool result <- ['action_' + f.name.normaliseString()/]();

[if (f.outgoing->size() = 1)]
	[let nextNode : FlowNode = f.getNextFlowNode()]
	if(result) {
		remove "[f.name.normaliseString()/]" from: tasks;
		counter_[f.name.normaliseString()/] <- counter_[f.name.normaliseString()/] + 1;
		[if (nextNode.oclIsTypeOf(Task))]
		if(not ("[nextNode.name.normaliseString()/]" in tasks)) {
			add "[nextNode.name.normaliseString()/]" to: tasks;
		}
		[elseif (nextNode.oclIsKindOf(Gateway))]
			[if (nextNode.oclAsType(Gateway).gatewayDirection = GatewayDirection::Diverging)]
		[generateDivergingConditions(nextNode)/]
			[elseif (nextNode.oclAsType(Gateway).gatewayDirection = GatewayDirection::Converging)]
		if(not ("[getConvergingReflexName(nextNode.oclAsType(Gateway))/]" in tasks)) {
			add "[getConvergingReflexName(nextNode.oclAsType(Gateway))/]" to: tasks;
		}
			[/if]
		[elseif (nextNode.oclIsTypeOf(EndEvent))]
		current_process <- nil;
		[/if]
	}		
}

	[/let]
[/if]

[/template]

[template public generateTasks(f : Gateway) post(trim())]
[if (f.gatewayDirection = GatewayDirection::Converging)]
if (("[f.getConvergingReflexName()/]" in tasks) [for (flow : SequenceFlow | f.incoming) separator(' ')]
[let name : String = flow.sourceRef.name]and not ("[name.normaliseString()/]" in tasks)[/let][/for]) {
		[let nextNode : FlowNode = f.getNextFlowNode()]
	remove "[f.getConvergingReflexName()/]" from: tasks;
			[if (nextNode.oclIsTypeOf(Task))]
	if(not ("[nextNode.name.normaliseString()/]" in tasks))	{
		add "[nextNode.name.normaliseString()/]" to: tasks;
	}
			[elseif (nextNode.oclIsKindOf(Gateway))]
				[if (nextNode.oclAsType(Gateway).gatewayDirection = GatewayDirection::Diverging)]
	[generateDivergingConditions(nextNode)/]
				[elseif (nextNode.oclAsType(Gateway).gatewayDirection = GatewayDirection::Converging)]
	if(not ("[getConvergingReflexName(nextNode.oclAsType(Gateway))/]" in tasks)) {
		add "[getConvergingReflexName(nextNode.oclAsType(Gateway))/]" to: tasks;
	}
				[/if]
			[elseif (nextNode.oclIsTypeOf(EndEvent))]
	current_process <- nil;
			[/if]
}
		[/let]
[/if]
[/template]

[template public generateTasks(f : EndEvent)]
//END OF REFLEXES RELATED TO PROCESS [f.eContainer(Process).name/]

[/template]

[comment we know that certain nodes can only have one outgoing sequence flow, so we can use the any(true) to get it /]

[query public getNextFlowNode(f : FlowNode) : FlowNode =
f.outgoing->any(true).targetRef
/]

[template public generateDivergingConditions(f : FlowNode)]
//TODO define template for type [f.eClass().name/]
[/template]

[template public generateDivergingConditions(gateway : ANDGateway) post(trim())]
[for (flow : SequenceFlow | gateway.outgoing)]
[generateDivergingConditions(flow.targetRef)/]
[/for]
[/template]

[template public generateDivergingConditions(gateway : XORGateway) post(trim())]
//Manage your conditions so that one and only one of the following tasks will be active
[for (flow : SequenceFlow | gateway.outgoing) separator('else ')]
[if (gateway.outgoing->size() > 1)]
if(true) {
	[generateDivergingConditions(flow.targetRef)/]
}
[else]
[generateDivergingConditions(flow.targetRef)/]
[/if]
[/for]
[/template]

[template public generateDivergingConditions(task : Task) post(trim())]
add "[task.name.normaliseString()/]" to: tasks;
[/template]

[template public generateDivergingConditions(event : EndEvent)]
[/template]

[template public getConvergingReflexName (gateway : Gateway) ]
merge[for (flow : SequenceFlow | gateway.incoming)][if(not flow.sourceRef.name.oclIsUndefined())]_[flow.sourceRef.name.normaliseString()/][else]_gateway[/if][/for]
[/template]

[template public handleNextTasks(f : FlowNode)]
	template_expression
[/template]